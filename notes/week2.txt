week2
---------------------------------------
IV. Linear Regression with Multiple Variables
---------------------------------------
Multiple features:
------------------
h(x) = theta0*x0 + theta1*x1 + theta2*x2 + ... + thetan*xn (x0 = 1)
=> multiplication of two matrix 1*(n+1), (n+1)*1
Cost Function: J(theta) = 1/2m * ∑(h(xi) - yi)ˆ2
Gradient decent:
    Repeat {
        thetaj := themaj - alpha * (∆ / ∆thetaj) * J(theta)
        }

    => thetaj := thetaj - alpha * (1/m) * ∑(h(xi) - yi)xij [i=1~m inputs, j=0~n parameters]

Feature Scaling:
----------------
Make sure features are on similar scale
Get every feature into approximately a -1 <= xi <= 1 range

Mean normalization:
-------------------
Replace xi with xi - mui to make features have approximately zero mean (do not apply to x0=1)

Debugging:
----------
Make sure Gradient decent works correctly: plot J(theta) - number iterations
- If alpha too small, slow convergence
- If alpha too large, J(thema) may not decrease on every iteration, may not converge

Choose alpha(learning rate):
----------------------------
try 0.001, 0,003, 0.01, 0.03.....

Polynomial Regression:
----------------------
h(theta) = theta0 + theta1x + theta2xˆ2 + theta3xˆ3
let x1 = x, x2 = xˆ2, x3 = xˆ3
=> change to linear regression

Normal Equation:
----------------
theta = (XˆT * X)ˆ-1 * XˆT * y
    - X is a matrix of m*(n+1)
    - y is a m-dimentional vector

Difference of gradient descent and normal equation:
---------------------------------------------------
GD:
    - need to choose learning rate
    - needs many iterations
    - works well even if n is very large
NE:
    - do not need to choose learning rate
    - do not need to iterate
    - need to compute (XˆT * X)ˆ-1 (O(nˆ3))
    - slow if n is very large

Normal Equation Noninvertibility:
---------------------------------
noninvertible matrices:  singular/degenerate
Octive: pinv will compute theta correctly even if (XˆT * X) is inconvertible
What if noninvertible:
    - Redundant features (linearly dependent)
        e.g. x1 = size in feetˆ2
             x2 = size in meterˆ2
    - Too many features (e.g. m < n)
        - Delete some features, or use regularization

---------------------------------------
V. Octave Tutorial
---------------------------------------

~= not equals to
% comment
PS1('>> '); hide version information
= assignment
; suppresses output
'String' string
pi
disp(sprintf('2 decimals: %0.2f', pi))
format long
format short
A = [1 2; 3 4; 5 6] matrix
v = [1; 2; 3] column vector
v = 1:0.1:2 increase by 0.1 until 2
v = 1:6
ones(2, 3)
2*ones(2, 3)
w = zeros(1, 3)
rand(3, 3) matrix of random numbers
randn(3, 3) Gaussien random numbers/normal random
w = -6 + sqrt(10)*(randn(1:10000))
hist(w)
hist(w, 50)
eye(4) 4 by 4 identity matrix
help eye help page
size(A)
size(A, 1) first dimension
length(A) return the longer dimension
pwd
cd './...'
ls
load featuresX.dat
load('featuresX.dat')
who - show all variables
whos - gives detail of all variables
clear featuresX - delete
clear - delete all
save hello.mat v;
save hello.txt v;
A(3, 2) - return the 3rd row and 2nd element of A
A(2, :) - : mean every elements along that column/row
A([1 3], :) - all elements from first and third rows
A(:, 2) = [10; 11; 12] - assignment
A = [A, [100; 101; 102]] - append new column to A
A(:) - put all elements of A into a single vector
A = [1 2; 3 4]
B = [5 6; 7 8]
C = [A B] - concatenate A and B by column
C = [A; B] - concatenate A and B by row
A .* B
A .^ B
1 ./ A
log(A)
exp(A)
abs(A)
-A
A + 1
A' - transpose
(A')'
a = [1 2 3 4]
max(a) - return max value of a
[val, ind] = max(a) - return the value and index of the max value of a
a < 3
find(a < 3) - return index
[r, c] = find(A > 7)
sum(a)
prod(a)
floor(a)
ceil(a)
max(A, [], 1) - find max value in each column
max(A, [], 2) - find max value in each row
max(A(:))
A = magic(9)
sum(A, 1) - sums up each column
sum(A, 2) - sums up each row
A .* eye(9)
sum(sum(A.*eye(9)))
sum(sum(A.*flipud(eye(9))))
flipud(eye(9))
A = magic(3)
temp = pinv(A)
temp * A

plot(x, y1)
hold on
plot(x, y2, 'r')
xlabel('time')
ylabel('value')
legend('sin', 'cos')
title('my plot')
cd './...'; print -dpng 'myPlot.png'
close
figure(1); plot(t, y1);
figure(2); plot(t, y2);
subplot(1, 2, 1); - divides plot a 1 by 2 grid, access first element
plot(t, y1)
subplot(1, 2, 2);
plot(t, y2)
axis([0.5 1 -1 1])
clf; - clears figure
A = magic(5)
imagesc(A)
imagesc(A), colorbar, colormap gray;
a = 1, b = 2, c = 3
a = 1; b = 2; c = 3

for i=1:10,
    v(i) = 2^i;
    end;
v

i = 1;
while i <= 5,
    v(i) = 100;
    i = i+1;
end;

i = 1;
while true,
    v(i) = 999;
    i = i+1;
    if i == 6,
        break;
    end;
end;

if ,
else if ,
else

addpath('./...') - search path
function [y1, y2] = squareAndCubeOfThisNumber(x)
y1 = x^2;
y2 = x^3;
=> save as squareAndCubeOfThisNumber.m in the search path

Vectorization:
--------------
∑thetai*xi = theta^T * X

Exercise:submit()
